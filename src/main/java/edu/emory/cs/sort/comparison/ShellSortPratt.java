package edu.emory.cs.sort.comparison;

        import java.util.ArrayList;
        import java.util.Comparator;
        import java.util.Collections;

public class ShellSortPratt<T extends Comparable<T>> extends ShellSort<T> {
    public ShellSortPratt(){this(Comparator.naturalOrder());}

    public ShellSortPratt(Comparator<T> comparator){this(comparator,1000); }

    public ShellSortPratt(Comparator<T> comparator, int n){super(comparator,n);}


    @Override
    protected void populateSequence(int n) {
        /*
        For this method, I multiplied the number by 2 for a number in a sequence that indic is referring to.
        indic*2 stops when it becomes bigger than 3^n. It continues when 3^n is added into the sequence.
         */

        /*Because ArrayList has a dynamic size and tend to remove and make a new arraylist everytime it goes
        through an iteration, it was best to create a new sequence with n/10 in the beginning.
         */

        this.sequence = new ArrayList<>(n/10);
        //if I don't do n/3, it will make a comparison of less than two numbers which causes an inefficiency.
        n= n/3;
        sequence.add(1);
        int indic = 0;
        int threeN = 1;
         for(int t = sequence.size() +1;;t++){
            if(sequence.get(indic)*2<(int)Math.pow(3,threeN)){
                sequence.add(sequence.get(indic)*2);
                indic++;
            }
            else {
                sequence.add((int)Math.pow(3,threeN));
                threeN++;
            }
            if(n<=sequence.get(indic-1)*2) break;
        }
    }

/*
Despite the long run time, this is the most efficient among other methods written here. This calculates pattern generated by the pratt sequence.
pratt sequence includes numbers with 2^n, 3^n, 6*number. For 6*number, number is another pratt sequence as it grows larger. So it is suitable to use 6*sequence.get(sequenceIndicator)
 */
/*
        this.sequence = new ArrayList<>(n/10);
        n=n/7;
        sequence.add(1);
        int seqInd = 0, pow2 = 1, pow3 = 1;
        //for (int i = sequence.size()-1; ; i++) {
        for(int i=0;;i++){
            if (Math.pow(2, pow2) < Math.pow(3, pow3) && Math.pow(2, pow2) < (6 * sequence.get(seqInd)) && Math.pow(2, pow2) < n) {
                sequence.add((int) Math.pow(2, pow2));
                pow2++;
            }
            else if (Math.pow(3, pow3) < Math.pow(2, pow2) && Math.pow(3, pow3) < (6 * sequence.get(seqInd)) && Math.pow(3, pow3) < n) {
                sequence.add((int) Math.pow(3, pow3));
                pow3++;
            }
            else if ((6 * sequence.get(seqInd)) < Math.pow(3, pow3) && (6 * sequence.get(seqInd)) < Math.pow(2, pow2) && (6 * sequence.get(seqInd)) < n) {
                sequence.add(6 * sequence.get(seqInd));
                seqInd++;
            }
            else {
                break;
            }
        }
    }
*/
/*
    Same as previous method, but has less efficiency because of the way it is written.
        sequence.add(1);
        int seqInd = 0,pow2 =1, pow3 =1;
        for (int i = sequence.size()-1; ; i++) {
            if(Math.pow(2,pow2)<Math.pow(3,pow3)&&Math.pow(2,pow2)<(6*sequence.get(seqInd))){
                sequence.add((int)Math.pow(2,pow2));
                pow2++;
            }
            else if(Math.pow(3,pow3)<Math.pow(2,pow2)&&Math.pow(3,pow3)<(6*sequence.get(seqInd))){
                sequence.add((int)Math.pow(3,pow3));
                pow3++;
            }
            else if(n<=sequence.get(i)){ break;}
            else{
                sequence.add(6*sequence.get(seqInd));
                seqInd++;
            }


        }
    }
    */

    @Override
    protected int getSequenceStartIndex(int n) {
        //because I declared n/3 in the populate sort, it is reasonable to declare a key n/3
        int index = Collections.binarySearch(sequence, n/7);
        if (index < 0) index = -(index + 1);
        if (index == sequence.size()) index--;
        return index;
    }

}

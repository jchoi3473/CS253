package edu.emory.cs.sort.comparison;

        import java.util.Comparator;
        import java.util.Collections;

public class ShellSortPratt<T extends Comparable<T>> extends ShellSort<T> {
    public ShellSortPratt(){this(Comparator.naturalOrder());}

    public ShellSortPratt(Comparator<T> comparator){this(comparator,1000); }

    public ShellSortPratt(Comparator<T> comparator, int n){super(comparator,n);}


    @Override
    protected void populateSequence(int n) {

        /*
        For this method, I multiplied the number by 2 for a number in a sequence that indic is referring to.
        indic*2 stops when it becomes bigger than 3^n. It continues when 3^n is added into the sequence.
        Although this is the most concise code that I came up with, because of sequence.get(indic), it is not the most
        efficient one.
        sequence.add(1);
        int indic = 0;
        int threeN = 1;
        while(true){
            if(sequence.get(indic)*2<(int)Math.pow(3,threeN)){
                sequence.add(sequence.get(indic)*2);
                indic++;
            }
            else {
                sequence.add((int)Math.pow(3,threeN));
                threeN++;
            }
            if(n<=sequence.get(indic-1)*2) break;
        }
    }
*/
/*
Despite the long run time, this is the most efficient among other methods written here. This calculates pattern generated by the pratt sequence.
pratt sequence includes numbers with 2^n, 3^n, 6*number. For 6*number, number is another pratt sequence as it grows larger. So it is suitable to use 6*sequence.get(sequenceIndicator)
 */
        sequence.add(1);
        int seqInd = 0, pow2 = 1, pow3 = 1;
        //for (int i = sequence.size()-1; ; i++) {
        while (true) {
            if (Math.pow(2, pow2) < Math.pow(3, pow3) && Math.pow(2, pow2) < (6 * sequence.get(seqInd)) && Math.pow(2, pow2) < n) {
                sequence.add((int) Math.pow(2, pow2));
                pow2++;
            }
            if (Math.pow(3, pow3) < Math.pow(2, pow2) && Math.pow(3, pow3) < (6 * sequence.get(seqInd)) && Math.pow(3, pow3) < n) {
                sequence.add((int) Math.pow(3, pow3));
                pow3++;
            }
            if ((6 * sequence.get(seqInd)) < Math.pow(3, pow3) && (6 * sequence.get(seqInd)) < Math.pow(2, pow2) && (6 * sequence.get(seqInd)) < n) {
                sequence.add(6 * sequence.get(seqInd));
                seqInd++;
            } else {
                break;
            }
        }
    }

    /*
    Same as previous method, but has less efficiency because of the way it is written.
        sequence.add(1);
        int seqInd = 0,pow2 =1, pow3 =1;
        for (int i = sequence.size()-1; ; i++) {
            if(Math.pow(2,pow2)<Math.pow(3,pow3)&&Math.pow(2,pow2)<(6*sequence.get(seqInd))){
                sequence.add((int)Math.pow(2,pow2));
                pow2++;
            }
            else if(Math.pow(3,pow3)<Math.pow(2,pow2)&&Math.pow(3,pow3)<(6*sequence.get(seqInd))){
                sequence.add((int)Math.pow(3,pow3));
                pow3++;
            }
            else if(n<=sequence.get(i)){ break;}
            else{
                sequence.add(6*sequence.get(seqInd));
                seqInd++;
            }


        }
    }
    */

    @Override
    protected int getSequenceStartIndex(int n) {
        int index = Collections.binarySearch(sequence, n);
        if (index < 0) index = -(index + 1);
        if (index == sequence.size()) index--;
        return index;
    }

}
